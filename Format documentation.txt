All integers are big-endian order.

The following types are available in a binary plist:
 1. boolean
 2. integer
 3. real
 4. date
 5. binary data
 6. string
 7. string (utf_16_be)
 8. array
 9. dictionary

A binary plist file has four sections:

1. The first 8 bytes are an identifier and always equal to 'bplist00'

2. Second is all of the elements in the plist, encoded and concatenated

3. Third is the concatenation of the offsets of all of the elements in the plist, each offset given as an unsigned integer in a fixed number of bytes. An object in the plist is has a reference number that is based on the 0-based indexing of this table, e.g. object number 0 is the object at the offset given first in this table.

4. The final 32 bytes have the following format:
 1. 6 bytes of \x00 padding
 2. a 1 byte integer which is the number of bytes for an offset value. Valid values are 1, 2, 3, or 4. Offset values are encoded as unsigned, big endian integers.
 3. a 1 byte integer which is the number of bytes for an object reference number. Valid values are 1 or 2. Reference numbers are encoded as unsigned, bug endian integers.
 4. 4 bytes of \x00 padding
 5. a 4 byte integer which is the number of objects in the plist
 6. 4 bytes of \x00 padding
 7. a 4 byte integer which is the reference number of the root object in the plist. This is usually zero.
 8. 4 bytes of \x00 padding
 9. a 4 byte integer which is the offset in the file of the start of the offset table, named above as the third element in a binary plist

-----
The encoding of the available types are as follows:

the first four bits are an id number of the object type, according to the following mapping:
 0x0 boolean
 0x1 integer
 0x2 real
 0x3 date
 0x4 binary data
 0x5 string
 0x6 unicode string
 0xa array
 0xd dictionary

the second four bits are the size of the object. If the value given is 15, and the type is not boolean, this means that the true object size is greater than can be expressed in four bits, and the next byte is the start of an encoded integer object which expresses the true size.

The encoding for the remainder of the object varies by type.

If the type is boolean, the object length is actually the value of the object. A value of 0 means null, 8 means False, and 9 means True. Any other value is invalid.

if the type is integer, the number of bytes is equal to 2 to the power of the object length previously found. Valid object lengths are 0, 1, 2, and 3
for 1, 2, 4, and 8 byte integers, respectively. The encoding is as a big-endian, signed integer in the appropriate number of bytes.

if the type is real the object length can be 2 or 3, corresponding to a byte length of 4 or 8. The encoding is as a single-precision or a double-precision float, accordingly. Byte order is reversed from IEEE 754.

if the type is date, the object length can be 3 or 4, corresponding to a byte length of 4 or 8. The value is seconds since the epoch of 1 January 2001, 0:00:00 GMT, encoded as a single or double precision float. Byte order is reversed from IEEE 754.

if the type is binary data then the object length is the byte length, and any value is valid. The bytes are not interpreted.

if the type is string, the object length is the byte length, and any value is valid. The encoding is ascii (I think).

If the type is unicode, the byte length is twice the object length, and any value is valid. The encoding is utf-16 (big endian)

if the type is array, the byte length is the object length times the bytes per object reference for this plist file, i.e. either 1 or two times the object length. Any object length is valid. The encoding is the concatenation of object reference numbers as unsigned, big-endian integers in a fixed space of the bytes per object reference for this plist file.

if the type is dictionary, the byte length is twice the object length times the bytes per object reference. The encoding is as the concatenation of two encoded arrays, the first of keys and the second of values. These are mapped to each other by virtue of occupying the same index in the array.

-----

When writing a binary plist file, any values that repeat within the file should be encoded only once and that single object referenced where ever that value repeats.